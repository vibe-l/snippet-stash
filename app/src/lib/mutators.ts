import type { CustomMutatorDefs, Transaction } from '@rocicorp/zero';
import { schema } from './zero-schema.js';
import type { InsertSnippet, Snippet, InsertSearchHistory } from './schema.js';

type Schema = typeof schema;

export function createMutators() {
    return {
        createSnippet: async (tx: Transaction, snippet: InsertSnippet) => {
            // The `id` will be generated by the database, but the optimistic layer
            // needs a temporary ID. Zero handles this automatically.
            // The `created_at` and `updated_at` fields have server-side defaults.
            await tx.mutate.snippets.insert(snippet);
        },
        updateSnippet: async (tx: Transaction, { id, ...snippet }: { id: number } & Partial<Omit<Snippet, 'id'>>) => {
            // We manually update the `updated_at` timestamp on the client for the optimistic update.
            await tx.mutate.snippets.update({ id, ...snippet, updated_at: new Date().toISOString() });
        },
        deleteSnippet: async (tx: Transaction, { id }: { id: number }) => {
            await tx.mutate.snippets.delete({ id });
        },
        updateSnippetUsage: async (tx: Transaction, { id }: { id: number }) => {
            await tx.mutate.snippets.update({ id, used_at: new Date().toISOString() });
        },
        addSearchHistory: async (tx: Transaction, search: InsertSearchHistory) => {
            // The original logic for adding search history is complex (update or insert).
            // For the optimistic client-side mutator, we'll just do a simple insert.
            // The more complex logic will be handled by the server-side mutator to ensure consistency.
            await tx.mutate.searchHistory.insert(search);
        },
        updateSearchHistoryScore: async (tx: Transaction, { id, score }: { id: number, score: number }) => {
            await tx.mutate.searchHistory.update({ id, score, last_used_at: new Date().toISOString() });
        },
        deleteSearchHistory: async (tx: Transaction, { id }: { id: number }) => {
            await tx.mutate.searchHistory.delete({ id });
        },
        clearSearchHistory: async (tx: Transaction) => {
            const allHistory = await tx.query.searchHistory.run();
            // This is not the most efficient way, but it's the only way to do this
            // with the basic client-side mutators. A server-side custom mutator
            // can implement this with a single `DELETE` statement.
            for (const item of allHistory) {
                await tx.mutate.searchHistory.delete({ id: item.id });
            }
        },
    } as const satisfies CustomMutatorDefs<Schema>;
}

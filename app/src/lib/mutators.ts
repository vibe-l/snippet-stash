import type { CustomMutatorDefs, Transaction } from '@rocicorp/zero';
import { schema } from './zero-schema.js';
import type { InsertSnippet, Snippet, InsertSearchHistory, InsertUser, User } from './schema.js';

type Schema = typeof schema;

export function createMutators() {
    return {
        // User methods
        createUser: async (tx: Transaction, user: InsertUser) => {
            await tx.mutate.users.insert(user);
        },
        
        // Snippet methods
        createSnippet: async (tx: Transaction, snippet: InsertSnippet) => {
            // The `id` will be generated by the database, but the optimistic layer
            // needs a temporary ID. Zero handles this automatically.
            // The `created_at` and `updated_at` fields have server-side defaults.
            await tx.mutate.snippets.insert(snippet);
        },
        updateSnippet: async (tx: Transaction, { id, ...snippet }: { id: number } & Partial<Omit<Snippet, 'id'>>) => {
            // We manually update the `updated_at` timestamp on the client for the optimistic update.
            await tx.mutate.snippets.update({ id, ...snippet, updated_at: new Date().toISOString() });
        },
        deleteSnippet: async (tx: Transaction, { id }: { id: number }) => {
            await tx.mutate.snippets.delete({ id });
        },
        updateSnippetUsage: async (tx: Transaction, { id }: { id: number }) => {
            await tx.mutate.snippets.update({ id, used_at: new Date().toISOString() });
        },
        
        // Search history methods
        addSearchHistory: async (tx: Transaction, search: InsertSearchHistory) => {
            const { query, selected_tags, filter_mode, score } = search;
            
            // Check if an identical search already exists
            const existing = await tx.query.searchHistory.where('query', query)
                .where('selected_tags', selected_tags)
                .where('filter_mode', filter_mode)
                .first();
            
            if (existing) {
                // If it exists, update the score and last_used_at timestamp
                await tx.mutate.searchHistory.update({
                    id: existing.id,
                    score: existing.score + (score || 1),
                    last_used_at: new Date().toISOString()
                });
            } else {
                // If it doesn't exist, create a new entry
                await tx.mutate.searchHistory.insert(search);
            }
        },
        updateSearchHistoryScore: async (tx: Transaction, { id, score }: { id: number, score: number }) => {
            await tx.mutate.searchHistory.update({ id, score, last_used_at: new Date().toISOString() });
        },
        deleteSearchHistory: async (tx: Transaction, { id }: { id: number }) => {
            await tx.mutate.searchHistory.delete({ id });
        },
        clearSearchHistory: async (tx: Transaction) => {
            const allHistory = await tx.query.searchHistory.run();
            // This is not the most efficient way, but it's the only way to do this
            // with the basic client-side mutators. A server-side custom mutator
            // can implement this with a single `DELETE` statement.
            for (const item of allHistory) {
                await tx.mutate.searchHistory.delete({ id: item.id });
            }
        },
    } as const satisfies CustomMutatorDefs<Schema>;
}
